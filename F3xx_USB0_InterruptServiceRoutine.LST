C51 COMPILER V7.20   F3XX_USB0_INTERRUPTSERVICEROUTINE                                     06/11/2009 12:00:42 PAGE 1   


C51 COMPILER V7.20, COMPILATION OF MODULE F3XX_USB0_INTERRUPTSERVICEROUTINE
OBJECT MODULE PLACED IN F3xx_USB0_InterruptServiceRoutine.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.exe F3xx_USB0_InterruptServiceRoutine.c DB OE LARGE OT(0,SPEED)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // F3xx_USB0_InterruptServiceRoutine.c
   3          //-----------------------------------------------------------------------------
   4          // Copyright 2005 Silicon Laboratories, Inc.
   5          // http://www.silabs.com
   6          //
   7          // Program Description:
   8          //
   9          // Source file for USB firmware. Includes top level ISR with SETUP,
  10          // and Endpoint data handlers.  Also includes routine for USB suspend,
  11          // reset, and procedural stall.
  12          //
  13          //
  14          // How To Test:    See Readme.txt
  15          //
  16          //
  17          // FID:            
  18          // Target:         C8051F32x
  19          // Tool chain:     Keil C51 7.50 / Keil EVAL C51
  20          //                 Silicon Laboratories IDE version 2.6
  21          // Command Line:   See Readme.txt
  22          // Project Name:   F3xx_MouseExample
  23          //
  24          //
  25          // Release 1.1
  26          //    -Minor code comment changes
  27          //    -16 NOV 2006
  28          // Release 1.0
  29          //    -Initial Revision (PD)
  30          //    -07 DEC 2005
  31          //
  32          
  33          //-----------------------------------------------------------------------------
  34          // Includes
  35          //-----------------------------------------------------------------------------
  36          #include "c8051f3xx.h"
  37          #include "F3xx_USB0_Register.h"
  38          #include "F3xx_USB0_InterruptServiceRoutine.h"
  39          #include "F3xx_USB0_Descriptor.h"
  40          #include "F3xx_USB0_ReportHandler.h"
  41          #include "spi.h"
  42          #include "F340_FlashPrimitives.h"
  43          #include "crc_check.h"
  44          #include <stdio.h>
  45          
  46          //-----------------------------------------------------------------------------
  47          // Global Variable Definitions
  48          //-----------------------------------------------------------------------------
  49          unsigned char USB0_STATE;               // Holds the current USB State
  50                                                 // def. in F3xx_USB0_InterruptServiceRoutine.h
  51          
  52          setup_buffer SETUP;                    // Buffer for current device
  53                                                 // request information
  54          
  55          unsigned int DATASIZE;                 // Size of data to return
C51 COMPILER V7.20   F3XX_USB0_INTERRUPTSERVICEROUTINE                                     06/11/2009 12:00:42 PAGE 2   

  56          unsigned int DATASENT;                 // Amount of data sent so far
  57          unsigned char* DATAPTR;                // Pointer to data to return
  58          
  59          unsigned char EP_STATUS[3] = {EP_IDLE, EP_HALT, EP_HALT};
  60                                                 // Holds the status for each endpoint
  61          
  62          unsigned char Feature_report_buffer[10];
  63          unsigned char Feature_IN_Report[10];
  64          unsigned char Feature_OUT_Report[10];
  65          
  66          
  67          //-----------------------------------------------------------------------------
  68          // Local Function Definitions
  69          //-----------------------------------------------------------------------------
  70          void Usb_Resume (void);                // resumes USB operation
  71          void Usb_Reset (void);                 // Called after USB bus reset
  72          void Handle_Control (void);            // Handle SETUP packet on EP 0
  73          void Handle_In1 (void);                // Handle in packet on EP 1
  74          void Handle_Out1 (void);               // Handle out packet on EP 1
  75          void Usb_Suspend (void);               // This routine called when
  76                                                 // suspend signalling on bus
  77          void Fifo_Read (unsigned char, unsigned int, unsigned char *);
  78                                                 // Used for multiple byte reads
  79                                                 // of Endpoint fifos
  80          void Fifo_Write_Foreground (unsigned char, unsigned int, unsigned char *);
  81                                                 // Used for multiple byte writes
  82                                                 // of Endpoint fifos in foreground
  83          void Fifo_Write_InterruptServiceRoutine (unsigned char, unsigned int,
  84                                                                                           unsigned char *);
  85                                                 // Used for multiple byte
  86                                                 // writes of Endpoint fifos
  87          
  88          extern void update_led_status(unsigned char res);
  89          
  90          
  91          //-----------------------------------------------------------------------------
  92          // Usb_ISR
  93          //-----------------------------------------------------------------------------
  94          //
  95          // Called after any USB type interrupt, this handler determines which type
  96          // of interrupt occurred, and calls the specific routine to handle it.
  97          //
  98          //-----------------------------------------------------------------------------
  99          void Usb_ISR (void) interrupt 8        // Top-level USB ISR
 100          {
 101   1      
 102   1         unsigned char bCommon, bIn, bOut;
 103   1         POLL_READ_BYTE (CMINT, bCommon);    // Read all interrupt registers
 104   1         POLL_READ_BYTE (IN1INT, bIn);       // this read also clears the register
 105   1         POLL_READ_BYTE (OUT1INT, bOut);
 106   1         {
 107   2            if (bCommon & rbRSUINT)          // Handle Resume interrupt
 108   2            {
 109   3               Usb_Resume ();
 110   3            }
 111   2            if (bCommon & rbRSTINT)          // Handle Reset interrupt
 112   2            {
 113   3               Usb_Reset ();
 114   3            }
 115   2            if (bIn & rbEP0)                 // Handle SETUP packet received
 116   2            {                                // or packet transmitted if Endpoint 0
 117   3               Handle_Control ();            // is in transmit mode
C51 COMPILER V7.20   F3XX_USB0_INTERRUPTSERVICEROUTINE                                     06/11/2009 12:00:42 PAGE 3   

 118   3            }
 119   2            if (bIn & rbIN1)                 // Handle In Packet sent, put new data
 120   2            {                                // on endpoint 1 fifo
 121   3               Handle_In1 ();
 122   3            }
 123   2            if (bOut & rbOUT1)               // Handle Out packet received, take
 124   2            {                                // data off endpoint 2 fifo
 125   3               Handle_Out1 ();
 126   3            }
 127   2            if (bCommon & rbSUSINT)          // Handle Suspend interrupt
 128   2            {
 129   3               Usb_Suspend ();
 130   3            }
 131   2         }
 132   1      }
 133          
 134          //-----------------------------------------------------------------------------
 135          // Support Routines
 136          //-----------------------------------------------------------------------------
 137          
 138          //-----------------------------------------------------------------------------
 139          // Usb_Reset
 140          //-----------------------------------------------------------------------------
 141          //
 142          // Return Value : None
 143          // Parameters   : None
 144          //
 145          // - Set state to default
 146          // - Clear Usb Inhibit bit
 147          //
 148          //-----------------------------------------------------------------------------
 149          
 150          void Usb_Reset (void)
 151          {
 152   1         USB0_STATE = DEV_DEFAULT;           // Set device state to default
 153   1      
 154   1         POLL_WRITE_BYTE (POWER, 0x01);      // Clear usb inhibit bit to enable USB
 155   1                                             // suspend detection
 156   1      
 157   1         EP_STATUS[0] = EP_IDLE;             // Set default Endpoint Status
 158   1         EP_STATUS[1] = EP_HALT;
 159   1         EP_STATUS[2] = EP_HALT;
 160   1      }
 161          
 162          
 163          
 164          //-----------------------------------------------------------------------------
 165          // Usb_Resume
 166          //-----------------------------------------------------------------------------
 167          //
 168          // Return Value : None
 169          // Parameters   : None
 170          //
 171          // Resume normal USB operation
 172          //
 173          //-----------------------------------------------------------------------------
 174          
 175          void Usb_Resume(void)
 176          {
 177   1         volatile int k;
 178   1      
 179   1         k++;
C51 COMPILER V7.20   F3XX_USB0_INTERRUPTSERVICEROUTINE                                     06/11/2009 12:00:42 PAGE 4   

 180   1      
 181   1         // Add code for resume
 182   1      }
 183          
 184          
 185          //-----------------------------------------------------------------------------
 186          // Handle_Control
 187          //-----------------------------------------------------------------------------
 188          //
 189          // Return Value : None
 190          // Parameters   : None
 191          //
 192          // - Decode Incoming SETUP requests
 193          // - Load data packets on fifo while in transmit mode
 194          //
 195          //-----------------------------------------------------------------------------
 196          
 197          void Handle_Control (void)
 198          {
 199   1         unsigned char ControlReg;           // Temporary storage for EP control
 200   1                                             // register
 201   1      
 202   1         POLL_WRITE_BYTE (INDEX, 0);         // Set Index to Endpoint Zero
 203   1         POLL_READ_BYTE (E0CSR, ControlReg); // Read control register
 204   1      
 205   1         if (EP_STATUS[0] == EP_ADDRESS)     // Handle Status Phase of Set Address
 206   1                                             // command
 207   1         {
 208   2            POLL_WRITE_BYTE (FADDR, SETUP.wValue.c[LSB]);
 209   2            EP_STATUS[0] = EP_IDLE;
 210   2         }
 211   1      
 212   1         if (ControlReg & rbSTSTL)           // If last packet was a sent stall,
 213   1         {                                   // reset STSTL bit and return EP0
 214   2                                             // to idle state
 215   2            POLL_WRITE_BYTE (E0CSR, 0);
 216   2            EP_STATUS[0] = EP_IDLE;
 217   2            return;
 218   2         }
 219   1      
 220   1         if (ControlReg & rbSUEND)           // If last SETUP transaction was
 221   1         {                                   // ended prematurely then set
 222   2            POLL_WRITE_BYTE (E0CSR, rbDATAEND);
 223   2            // Serviced SETUP End bit and return EP0
 224   2            POLL_WRITE_BYTE (E0CSR, rbSSUEND);
 225   2            EP_STATUS[0] = EP_IDLE;          // to idle state
 226   2         }
 227   1      
 228   1         if (EP_STATUS[0] == EP_IDLE)        // If Endpoint 0 is in idle mode
 229   1         {
 230   2            if (ControlReg & rbOPRDY)        // Make sure that EP 0 has an Out Packet
 231   2            {                                // ready from host although if EP0
 232   3                                             // is idle, this should always be the
 233   3                                             // case
 234   3               Fifo_Read (FIFO_EP0, 8, (unsigned char *)&SETUP);
 235   3                                             // Get SETUP Packet off of Fifo,
 236   3                                             // it is currently Big-Endian
 237   3      
 238   3                                             // Compiler Specific - these next three
 239   3                                             // statements swap the bytes of the
 240   3                                             // SETUP packet words to Big Endian so
 241   3                                             // they can be compared to other 16-bit
C51 COMPILER V7.20   F3XX_USB0_INTERRUPTSERVICEROUTINE                                     06/11/2009 12:00:42 PAGE 5   

 242   3                                             // values elsewhere properly
 243   3               SETUP.wValue.i = SETUP.wValue.c[MSB] + 256*SETUP.wValue.c[LSB];
 244   3               SETUP.wIndex.i = SETUP.wIndex.c[MSB] + 256*SETUP.wIndex.c[LSB];
 245   3               SETUP.wLength.i = SETUP.wLength.c[MSB] + 256*SETUP.wLength.c[LSB];
 246   3      
 247   3                      // Intercept HID class-specific requests
 248   3                      if( (SETUP.bmRequestType & ~0x80) == DSC_HID) {
 249   4                              switch (SETUP.bRequest) {
 250   5                                      case GET_REPORT:
 251   5                                              Get_Report ();
 252   5                                              break;
 253   5                                      case SET_REPORT:
 254   5                                              Set_Report ();
 255   5                                              break;
 256   5                                      case GET_IDLE:
 257   5                                              Get_Idle ();
 258   5                                              break;
 259   5                                      case SET_IDLE:
 260   5                                              Set_Idle ();
 261   5                                              break;
 262   5                                      case GET_PROTOCOL:
 263   5                                              Get_Protocol ();
 264   5                                              break;
 265   5                                      case SET_PROTOCOL:
 266   5                                              Set_Protocol ();
 267   5                                              break;
 268   5                          default:
 269   5                        Force_Stall ();      // Send stall to host if invalid
 270   5                          break;                 // request
 271   5                              }
 272   4                      } else
 273   3      
 274   3               switch (SETUP.bRequest)       // Call correct subroutine to handle
 275   3               {                             // each kind of standard request
 276   4                  case GET_STATUS:
 277   4                     Get_Status ();
 278   4                     break;
 279   4                  case CLEAR_FEATURE:
 280   4                     Clear_Feature ();
 281   4                     break;
 282   4                  case SET_FEATURE:
 283   4                     Set_Feature ();
 284   4                     break;
 285   4                  case SET_ADDRESS:
 286   4                     Set_Address ();
 287   4                     break;
 288   4                  case GET_DESCRIPTOR:
 289   4                     Get_Descriptor ();
 290   4                     break;
 291   4                  case GET_CONFIGURATION:
 292   4                     Get_Configuration ();
 293   4                     break;
 294   4                  case SET_CONFIGURATION:
 295   4                     Set_Configuration ();
 296   4                     break;
 297   4                  case GET_INTERFACE:
 298   4                     Get_Interface ();
 299   4                     break;
 300   4                  case SET_INTERFACE:
 301   4                     Set_Interface ();
 302   4                     break;
 303   4                  default:
C51 COMPILER V7.20   F3XX_USB0_INTERRUPTSERVICEROUTINE                                     06/11/2009 12:00:42 PAGE 6   

 304   4                     Force_Stall ();         // Send stall to host if invalid request
 305   4                     break;
 306   4               }
 307   3            }
 308   2         }
 309   1      
 310   1         if (EP_STATUS[0] == EP_TX)          // See if endpoint should transmit
 311   1         {
 312   2            if (!(ControlReg & rbINPRDY) )   // Don't overwrite last packet
 313   2            {
 314   3               // Read control register
 315   3               POLL_READ_BYTE (E0CSR, ControlReg);
 316   3      
 317   3               // Check to see if SETUP End or Out Packet received, if so do not put
 318   3               // any new data on FIFO
 319   3               if ((!(ControlReg & rbSUEND)) || (!(ControlReg & rbOPRDY)))
 320   3               {
 321   4                  // Add In Packet ready flag to E0CSR bitmask
 322   4                  ControlReg = rbINPRDY;
 323   4                  if (DATASIZE >= EP0_PACKET_SIZE)
 324   4                  {
 325   5                     // Break Data into multiple packets if larger than Max Packet
 326   5                     Fifo_Write_InterruptServiceRoutine (FIFO_EP0, EP0_PACKET_SIZE,
 327   5                                                                                        (unsigned char*)DATAPTR);
 328   5                     // Advance data pointer
 329   5                     DATAPTR  += EP0_PACKET_SIZE;
 330   5                     // Decrement data size
 331   5                     DATASIZE -= EP0_PACKET_SIZE;
 332   5                     // Increment data sent counter
 333   5                     DATASENT += EP0_PACKET_SIZE;
 334   5                  }
 335   4                  else
 336   4                  {
 337   5                     // If data is less than Max Packet size or zero
 338   5                     Fifo_Write_InterruptServiceRoutine (FIFO_EP0, DATASIZE,
 339   5                                                                                        (unsigned char*)DATAPTR);
 340   5                     ControlReg |= rbDATAEND;// Add Data End bit to bitmask
 341   5                     EP_STATUS[0] = EP_IDLE; // Return EP 0 to idle state
 342   5                  }
 343   4                  if (DATASENT == SETUP.wLength.i)
 344   4                  {
 345   5                     // This case exists when the host requests an even multiple of
 346   5                     // your endpoint zero max packet size, and you need to exit
 347   5                     // transmit mode without sending a zero length packet
 348   5                     ControlReg |= rbDATAEND;// Add Data End bit to mask
 349   5                     EP_STATUS[0] = EP_IDLE; // Return EP 0 to idle state
 350   5                  }
 351   4                  // Write mask to E0CSR
 352   4                  POLL_WRITE_BYTE(E0CSR, ControlReg);
 353   4               }
 354   3            }
 355   2         }
 356   1      
 357   1         if (EP_STATUS[0] == EP_RX)          // See if endpoint should transmit
 358   1         {
 359   2            // Read control register
 360   2            POLL_READ_BYTE (E0CSR, ControlReg);
 361   2            if (ControlReg & rbOPRDY)        // Verify packet was received
 362   2            {
 363   3               ControlReg = rbSOPRDY;
 364   3                      if (DATASIZE >= EP0_PACKET_SIZE)
 365   3                      {
C51 COMPILER V7.20   F3XX_USB0_INTERRUPTSERVICEROUTINE                                     06/11/2009 12:00:42 PAGE 7   

 366   4                  Fifo_Read(FIFO_EP0, EP0_PACKET_SIZE, (unsigned char*)DATAPTR);
 367   4                  // Advance data pointer
 368   4                  DATAPTR  += EP0_PACKET_SIZE;
 369   4                  // Decrement data size
 370   4                  DATASIZE -= EP0_PACKET_SIZE;
 371   4                  // Increment data sent counter
 372   4                  DATASENT += EP0_PACKET_SIZE;
 373   4                      }
 374   3                      else
 375   3                      {
 376   4                  // read bytes from FIFO
 377   4                  Fifo_Read (FIFO_EP0, DATASIZE, (unsigned char*) DATAPTR);
 378   4      
 379   4                  ControlReg |= rbDATAEND;   // signal end of data
 380   4                  EP_STATUS[0] = EP_IDLE;    // set Endpoint to IDLE
 381   4                      }
 382   3                      if (DATASENT == SETUP.wLength.i)
 383   3                      {
 384   4                              ControlReg |= rbDATAEND;
 385   4                              EP_STATUS[0] = EP_IDLE;
 386   4                      }
 387   3               // if EP_RX mode was entered through a SET_REPORT request,
 388   3               // call the ReportHandler_OUT function and pass the Report
 389   3               // ID, which is the first by the of DATAPTR's buffer
 390   3               if ( (EP_STATUS[0] == EP_IDLE) && (SETUP.bRequest == SET_REPORT) )
 391   3               {
 392   4                              if((SETUP.wValue.c[MSB] == HID_FEATURE)
 393   4                              && (SETUP.wValue.c[LSB] == 1)                   // report ID     
 394   4                              && (SETUP.wLength.i == 4))                              // length
 395   4                              {
 396   5                                      if(Feature_report_buffer[0] == 1)
 397   5                                      {
 398   6                                              switch(Feature_report_buffer[1])
 399   6                                              {
 400   7                                                      case 0x30:
 401   7                                                              switch(Feature_report_buffer[2])
 402   7                                                              {
 403   8                                                                      case 0x0F:
 404   8                                                                              spi_write_sensor(Feature_report_buffer[2], Feature_report_buffer[3]);
 405   8                                                                              resolution = Feature_report_buffer[3];                                                                          //load default resolution
 406   8                                                                              spi_write_eeprom(0x0000, resolution);
 407   8                                                                              update_led_status(resolution);
 408   8                                                                              break;
 409   8                                                                      case 0x20:
 410   8                                                                      case 0x21:
 411   8                                                                      case 0x22:
 412   8                                                                      case 0x23:
 413   8                                                                              spi_write_sensor(Feature_report_buffer[2], Feature_report_buffer[3]);
 414   8                                                                              break;
 415   8                                                                      default:
 416   8                                                                              spi_write_sensor(Feature_report_buffer[2], Feature_report_buffer[3]);
 417   8                                                                              break;
 418   8                                                              }
 419   7                                                              break;
 420   7                                                      case 0x31:
 421   7                                                              Feature_report_buffer[3] = spi_read_sensor(Feature_report_buffer[2]);
 422   7                                                              break;
 423   7                                                      case 0x33:
 424   7                                                              image_buffer[1] = 0;
 425   7                                                              grab_image = 1;
 426   7                                                              // Grab Image;
 427   7                                                              break;
C51 COMPILER V7.20   F3XX_USB0_INTERRUPTSERVICEROUTINE                                     06/11/2009 12:00:42 PAGE 8   

 428   7                                                      case 0x34:
 429   7                                                              Feature_report_buffer[2] = image_buffer[1];
 430   7                                                              break;
 431   7                                                      case 0x40:
 432   7      //                                                      spi_write_eeprom(Feature_report_buffer[2], Feature_report_buffer[3]);
 433   7                                                              break;
 434   7                                                      case 0x41:
 435   7      //                                                      Feature_report_buffer[3] = spi_read_eeprom(Feature_report_buffer[2]);
 436   7                                                              break;
 437   7                                                      case 0x50:
 438   7      //                                                      FLASH_ByteWrite (0x3A00 + Feature_report_buffer[2], Feature_report_buffer[3]);
 439   7                                                              break;
 440   7                                                      case 0x51:
 441   7      //                                                      Feature_report_buffer[3] = FLASH_ByteRead(0x3A00 + Feature_report_buffer[2]);
 442   7                                                              break;
 443   7                                                      case 0x52:
 444   7      //                                                      Feature_report_buffer[3] = 0x52;
 445   7      //                                                      FLASH_PageErase(0x3A00 + Feature_report_buffer[2]);
 446   7                                                              break;
 447   7                                                      case 0x71:
 448   7                                                              Feature_report_buffer[2] = FIRMWARE_VERSION_MAJOR;
 449   7                                                              Feature_report_buffer[3] = FIRMWARE_VERSION_MINOR;
 450   7                                                              break;
 451   7      
 452   7                                                      case 0x80:
 453   7                                                              switch(Feature_report_buffer[2])
 454   7                                                              {
 455   8                                                                      case 0x01:
 456   8                                                                              mouse_enabled = Feature_report_buffer[3];
 457   8                                                                              Feature_report_buffer[3] = 0x01;
 458   8                                                                              break;
 459   8                                                                      default:
 460   8                                                                              Feature_report_buffer[3] = 0x00;
 461   8                                                                              break;
 462   8                                                              }
 463   7                                                              break;
 464   7                                                      case 0x81:
 465   7                                                              switch(Feature_report_buffer[2])
 466   7                                                              {
 467   8                                                                      case 0x01:
 468   8                                                                              Feature_report_buffer[3] = mouse_enabled;
 469   8                                                                              break;
 470   8                                                                      default:
 471   8                                                                              Feature_report_buffer[3] = 0x00;
 472   8                                                                              break;
 473   8                                                              }
 474   7                                                              break;
 475   7      
 476   7                                                      case 0x91:
 477   7                                                              image_buffer[0] = Feature_report_buffer[1];
 478   7                                                              image_buffer[1] = 1;
 479   7                                                              switch(Feature_report_buffer[2])
 480   7                                                              {
 481   8                                                                      case 0x01: // customer type
 482   8                                                                              sprintf(&image_buffer[2], "%s", CUSTOMER);
 483   8                                                                              break;
 484   8                                                                      case 0x02: // nature
 485   8                                                                              sprintf(&image_buffer[2], "%s", SAMPLE_TYPE);
 486   8                                                                              break;
 487   8                                                                      default:
 488   8                                                                              image_buffer[1] = 0;
 489   8                                                                              break;
C51 COMPILER V7.20   F3XX_USB0_INTERRUPTSERVICEROUTINE                                     06/11/2009 12:00:42 PAGE 9   

 490   8                                                              }
 491   7                                                              break;
 492   7      
 493   7                                                      case 0xA0:      // 2nd Step     // Write Data   
 494   7                                                              FLASH_ByteWrite((SROM_TEMP_ADDR + srom_addr), Feature_report_buffer[3]);
 495   7                                                              crc_return = Eight_Bit_CRC(crc_return, Feature_report_buffer[3]);
 496   7                                                              srom_addr++;
 497   7                                                              break;
 498   7                                                      case 0xA1:      // 3rd Step     // Read CRC
 499   7                                                              Feature_report_buffer[3] = crc_return;
 500   7                                                              break;
 501   7                                                      case 0xA2:      // 1st Step     // Erase        
 502   7                                                              WDT_Disable();
 503   7                                                              FLASH_PageErase(SROM_TEMP_ADDR + 0x0000);
 504   7                                                              FLASH_PageErase(SROM_TEMP_ADDR + 0x0200);
 505   7                                                              FLASH_PageErase(SROM_TEMP_ADDR + 0x0400);
 506   7                                                              FLASH_PageErase(SROM_TEMP_ADDR + 0x0600);
 507   7                                                              FLASH_PageErase(SROM_TEMP_ADDR + 0x0800);
 508   7                                                              FLASH_PageErase(SROM_TEMP_ADDR + 0x0A00);
 509   7                                                              FLASH_PageErase(SROM_TEMP_ADDR + 0x0C00);                                                       
 510   7      
 511   7                                                              srom_addr = 0;
 512   7                                                              crc_return = 0;
 513   7                                                              srom_start = 1;
 514   7                                                              break;
 515   7                                                      case 0xA3:      // 4nd Step     // Set download status
 516   7                                                              FLASH_ByteWrite ((SROM_TEMP_ADDR + 0x0C02), Feature_report_buffer[3]);
 517   7                                                              if(Feature_report_buffer[3] == 0x01)
 518   7                                                              {
 519   8                                                                      srom_size.w = srom_addr;
 520   8                                                                      FLASH_ByteWrite ((SROM_TEMP_ADDR + 0x0C00), srom_size.b[0]);
 521   8                                                                      FLASH_ByteWrite ((SROM_TEMP_ADDR + 0x0C01), srom_size.b[1]);
 522   8                                                                      srom_success = 1;
 523   8                                                              }
 524   7                                                              else
 525   7                                                              {
 526   8                                                                      WDT_Enable();
 527   8                                                                      srom_start = 0;
 528   8                                                              }
 529   7                                                              break;
 530   7                                                      
 531   7                                                      default:
 532   7                                                              break;
 533   7                                              }
 534   6                                      }
 535   5                              }
 536   4                              else if((SETUP.wValue.c[MSB] == HID_OUTPUT_REPORT)
 537   4                              && (SETUP.wValue.c[LSB] == 0)                   // report ID     
 538   4                              && (SETUP.wIndex.i == 0)
 539   4                              && (SETUP.wLength.i == 3))                              // length
 540   4                              {
 541   5                                      received = 1;
 542   5      
 543   5                              }
 544   4               }
 545   3      
 546   3               if (EP_STATUS[0] != EP_STALL) POLL_WRITE_BYTE (E0CSR, ControlReg);
 547   3            }
 548   2         }
 549   1      }
 550          
 551          //-----------------------------------------------------------------------------
C51 COMPILER V7.20   F3XX_USB0_INTERRUPTSERVICEROUTINE                                     06/11/2009 12:00:42 PAGE 10  

 552          // Handle_In1
 553          //-----------------------------------------------------------------------------
 554          //
 555          // Handler will be entered after the endpoint's buffer has been
 556          // transmitted to the host.  In1_StateMachine is set to Idle, which
 557          // signals the foreground routine SendPacket that the Endpoint
 558          // is ready to transmit another packet.
 559          //-----------------------------------------------------------------------------
 560          void Handle_In1 ()
 561          {
 562   1            EP_STATUS[1] = EP_IDLE;
 563   1      }
 564          
 565          //-----------------------------------------------------------------------------
 566          // Handle_Out1
 567          //-----------------------------------------------------------------------------
 568          // Take the received packet from the host off the fifo and put it into
 569          // the Out_Packet array.
 570          //
 571          //-----------------------------------------------------------------------------
 572          void Handle_Out1 ()
 573          {
 574   1      
 575   1         unsigned char Count = 0;
 576   1         unsigned char ControlReg;
 577   1      
 578   1         POLL_WRITE_BYTE (INDEX, 1);         // Set index to endpoint 2 registers
 579   1         POLL_READ_BYTE (EOUTCSR1, ControlReg);
 580   1      
 581   1         if (EP_STATUS[1] == EP_HALT)        // If endpoint is halted, send a stall
 582   1         {
 583   2            POLL_WRITE_BYTE (EOUTCSR1, rbOutSDSTL);
 584   2         }
 585   1      
 586   1         else                                // Otherwise read received packet
 587   1                                             // from host
 588   1         {
 589   2            if (ControlReg & rbOutSTSTL)     // Clear sent stall bit if last
 590   2                                             // packet was a stall
 591   2            {
 592   3               POLL_WRITE_BYTE (EOUTCSR1, rbOutCLRDT);
 593   3            }
 594   2      
 595   2                      OUT_BUFFER.Ptr = OUT_PACKET;
 596   2                      OUT_BUFFER.Length = 3;
 597   2      
 598   2            Fifo_Read(FIFO_EP1, OUT_BUFFER.Length, OUT_BUFFER.Ptr);
 599   2      
 600   2            // process data according to received Report ID.
 601   2            // In systems with Report Descriptors that do not define report IDs,
 602   2            // the host will still format OUT packets with a prefix byte
 603   2            // of '0x00'.
 604   2      
 605   2            POLL_WRITE_BYTE (EOUTCSR1, 0);   // Clear Out Packet ready bit
 606   2      
 607   2              received = 1;
 608   2      
 609   2         }
 610   1      }
 611          
 612          //-----------------------------------------------------------------------------
 613          // Usb_Suspend
C51 COMPILER V7.20   F3XX_USB0_INTERRUPTSERVICEROUTINE                                     06/11/2009 12:00:42 PAGE 11  

 614          //-----------------------------------------------------------------------------
 615          // Enter suspend mode after suspend signalling is present on the bus
 616          //
 617          void Usb_Suspend (void)
 618          {
 619   1         volatile int k;
 620   1         k++;
 621   1      }
 622          
 623          //-----------------------------------------------------------------------------
 624          // Fifo_Read
 625          //-----------------------------------------------------------------------------
 626          //
 627          // Return Value : None
 628          // Parameters   :
 629          //                1) BYTE addr : target address
 630          //                2) unsigned int uNumBytes : number of bytes to unload
 631          //                3) BYTE * pData : read data destination
 632          //
 633          // Read from the selected endpoint FIFO
 634          //
 635          //-----------------------------------------------------------------------------
 636          void Fifo_Read (unsigned char addr, unsigned int uNumBytes,
 637                         unsigned char * pData)
 638          {
 639   1         int i;
 640   1      
 641   1         if (uNumBytes)                      // Check if >0 bytes requested,
 642   1         {
 643   2            USB0ADR = (addr);                // Set address
 644   2            USB0ADR |= 0xC0;                 // Set auto-read and initiate
 645   2                                             // first read
 646   2      
 647   2            // Unload <NumBytes> from the selected FIFO
 648   2            for(i=0;i< (uNumBytes);i++)
 649   2            {
 650   3               while (USB0ADR & 0x80);       // Wait for BUSY->'0' (data ready)
 651   3               pData[i] = USB0DAT;           // Copy data byte
 652   3            }
 653   2      
 654   2            //while(USB0ADR & 0x80);         // Wait for BUSY->'0' (data ready)
 655   2            USB0ADR = 0;                     // Clear auto-read
 656   2         }
 657   1      }
 658          
 659          //-----------------------------------------------------------------------------
 660          // Fifo_Write
 661          //-----------------------------------------------------------------------------
 662          //
 663          // Return Value : None
 664          // Parameters   :
 665          //                1) BYTE addr : target address
 666          //                2) unsigned int uNumBytes : number of bytes to unload
 667          //                3) BYTE * pData : location of source data
 668          //
 669          // Write to the selected endpoint FIFO
 670          //
 671          // Fifo_Write_Foreground is used for function calls made in the foreground routines,
 672          // and Fifo_Write_InterruptServiceRoutine is used for calls made in an ISR.
 673          
 674          //-----------------------------------------------------------------------------
 675          
C51 COMPILER V7.20   F3XX_USB0_INTERRUPTSERVICEROUTINE                                     06/11/2009 12:00:42 PAGE 12  

 676          void Fifo_Write_Foreground (unsigned char addr, unsigned int uNumBytes,
 677                              unsigned char * pData)
 678          {
 679   1         int i;
 680   1      
 681   1         // If >0 bytes requested,
 682   1         if (uNumBytes)
 683   1         {
 684   2            while (USB0ADR & 0x80);          // Wait for BUSY->'0'
 685   2                                             // (register available)
 686   2            USB0ADR = (addr);                // Set address (mask out bits7-6)
 687   2      
 688   2            // Write <NumBytes> to the selected FIFO
 689   2            for(i=0;i<uNumBytes;i++)
 690   2            {
 691   3               USB0DAT = pData[i];
 692   3               while (USB0ADR & 0x80);       // Wait for BUSY->'0' (data ready)
 693   3            }
 694   2         }
 695   1      }
 696          
 697          void Fifo_Write_InterruptServiceRoutine (unsigned char addr,
 698                                                   unsigned int uNumBytes,
 699                                                   unsigned char * pData)
 700          {
 701   1         int i;
 702   1      
 703   1         // If >0 bytes requested,
 704   1         if (uNumBytes)
 705   1         {
 706   2            while (USB0ADR & 0x80);          // Wait for BUSY->'0'
 707   2                                             // (register available)
 708   2            USB0ADR = (addr);                // Set address (mask out bits7-6)
 709   2      
 710   2            // Write <NumBytes> to the selected FIFO
 711   2            for (i=0; i<uNumBytes; i++)
 712   2            {
 713   3               USB0DAT = pData[i];
 714   3               while (USB0ADR & 0x80);       // Wait for BUSY->'0' (data ready)
 715   3            }
 716   2         }
 717   1      }
 718          
 719          //-----------------------------------------------------------------------------
 720          // Force_Stall
 721          //-----------------------------------------------------------------------------
 722          //
 723          // Return Value : None
 724          // Parameters   : None
 725          //
 726          // Force a procedural stall to be sent to the host
 727          //
 728          //-----------------------------------------------------------------------------
 729          
 730          void Force_Stall (void)
 731          {
 732   1         POLL_WRITE_BYTE (INDEX, 0);
 733   1         POLL_WRITE_BYTE (E0CSR, rbSDSTL);   // Set the send stall bit
 734   1         EP_STATUS[0] = EP_STALL;            // Put the endpoint in stall status
 735   1      }
 736          
 737          
C51 COMPILER V7.20   F3XX_USB0_INTERRUPTSERVICEROUTINE                                     06/11/2009 12:00:42 PAGE 13  

 738          //-----------------------------------------------------------------------------
 739          // SendPacket
 740          //-----------------------------------------------------------------------------
 741          //
 742          // Return Value - None
 743          // Parameters - Report ID that's used to call the appropriate IN handler
 744          //
 745          // This function can be called by other routines to force an IN packet
 746          // transmit.  It takes as an input the Report ID of the packet to be
 747          // transmitted.
 748          //-----------------------------------------------------------------------------
 749          
 750          void SendPacket (void)
 751          {
 752   1         bit EAState;
 753   1         unsigned char ControlReg;
 754   1      
 755   1         EAState = EA;
 756   1         EA = 0;
 757   1      
 758   1         POLL_WRITE_BYTE (INDEX, 1);         // Set index to endpoint 1 registers
 759   1      
 760   1         // Read contol register for EP 1
 761   1          POLL_READ_BYTE (EINCSR1, ControlReg);
 762   1      
 763   1         if (EP_STATUS[1] == EP_HALT)        // If endpoint is currently halted,
 764   1                                             // send a stall
 765   1         {
 766   2            POLL_WRITE_BYTE (EINCSR1, rbInSDSTL);
 767   2         }
 768   1      
 769   1         else if(EP_STATUS[1] == EP_IDLE)
 770   1         {
 771   2            // the state will be updated inside the ISR handler
 772   2            EP_STATUS[1] = EP_TX;
 773   2      
 774   2            if (ControlReg & rbInSTSTL)      // Clear sent stall if last
 775   2                                             // packet returned a stall
 776   2            {
 777   3               POLL_WRITE_BYTE (EINCSR1, rbInCLRDT);
 778   3            }
 779   2      
 780   2            if (ControlReg & rbInUNDRUN)     // Clear underrun bit if it was set
 781   2            {
 782   3               POLL_WRITE_BYTE (EINCSR1, 0x00);
 783   3            }
 784   2      
 785   2      //      ReportHandler_IN_Foreground (ReportID);
 786   2      
 787   2            // Put new data on Fifo
 788   2            Fifo_Write_Foreground (FIFO_EP1, IN_BUFFER.Length,
 789   2                          (unsigned char *)IN_BUFFER.Ptr);
 790   2            POLL_WRITE_BYTE (EINCSR1, rbInINPRDY);
 791   2                                             // Set In Packet ready bit,
 792   2         }                                   // indicating fresh data on FIFO 1
 793   1      
 794   1         EA = EAState;
 795   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2702    ----
C51 COMPILER V7.20   F3XX_USB0_INTERRUPTSERVICEROUTINE                                     06/11/2009 12:00:42 PAGE 14  

   CONSTANT SIZE    =      5    ----
   XDATA SIZE       =     84    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
